---
title: 'Why do programming languages succeed and fail?'
excerpt: "It's not just because they're good or bad"
date: '2023-03-24
author:
  name: Riley Stewart
---
Why do programming languages succeed and fail? It's not just because they're good or bad. If the opinions of programmers determined success and all was good in the world, we would all be writing Rust and Lisp instead of Python and Java. So what does it take? Programming languages that succeed build the world of software. This clearly matters but is little examined, so let's dive in.

### Well-designed
Of course, being a well-designed language still matters for overall success, but it is far from the determining factor. History contains countless beautiful also-beens and hideous successes (no need to name them). No matter how sound the type system, how expressive the syntax, how perfect the paradigm, nothing is guaranteed in this field. But success is not random! So let's look at what else drives it.

### Surfing hype
Some languages ride waves of hype on their way to glory, taking advantage of fickle forces like memetics and marketing. Java is perhaps the most striking example of this, quickly taking the programming world by storm at the height of the object craze in the late 90s with its promise of "write once, run anywhere" for both enterprise software and web applets. Such was the moment that Javascript was baldly named after it despite only having a superficial resemblance; it would later make applets obsolete. Poor Smalltalk cratered almost overnight as corporate users flocked to Java (also because it was free - more on that later). By the early 2000s, Java was dominating programming and still is, even if the hype is all gone.

More recently, we've witnessed a different kind of hype cycle with Rust. After spending a few wise years in beta where it could refine the design, Rust has been propelled by an enthusiastic online community (sometimes amusingly referred to as the Rust Evangelism Strike Force) which ceaselessly extolled its virtues of safety and speed in arguing to "rewrite it in rust". Though I think Rust is a good language that deserves to succeed, it wouldn't have what measured success it has attained without the help of these dynamics (case in point: a great deal of available Rust jobs are in the similarly hypey crypto space).
### Killer framework
Ruby, Elixir
Ruby on Rails is the epitome of the killer framework. Before it hit the scene, Ruby was just another fringe dynamic language that focused on delighting developers. The framework made it easy to build database driven monolithic applications and quickly became the choice for a new breed of products, such as Twitter and Github. Developers learned Ruby just to use Rails, and the two became synonymous. 
### Platform blessed
Swift/Objective-C, JS
### Free and available
C/C++, Java, everything
### Third-party ecosystem
Python
### Corporate backing
Java, Go
### IDE friendly
C#, Java, Typescript
