
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/src/style.css">
    <title>rileystew.art - Why do programming languages succeed and fail?</title>
  </head>
  <body>
    <h3>Why do programming languages succeed and fail?</h3>
    <p>Why do programming languages succeed and fail? It&#39;s not just because they&#39;re good or bad. If the opinions of programmers determined success and all was good in the world, we would all be writing Rust and Lisp instead of Python and Java. So what does it take? Programming languages that succeed build the world of software. This clearly matters but is little examined, so let&#39;s dive in.</p>
<h3>Well-designed</h3>
<p>Of course, being a well-designed language still matters for overall success, but it is far from the determining factor. History contains countless beautiful also-beens and hideous successes (no need to name them). No matter how sound the type system, how expressive the syntax, how perfect the paradigm, nothing is guaranteed in this field. But success is not random! So let&#39;s look at what else drives it.</p>
<h3>Surfing hype</h3>
<p>Some languages ride waves of hype on their way to glory, taking advantage of fickle forces like memetics and marketing. Java is perhaps the most striking example of this, quickly taking the programming world by storm at the height of the object craze in the late 90s with its promise of &quot;write once, run anywhere&quot; for both enterprise software and web applets. Such was the moment that Javascript was baldly named after it despite only having a superficial resemblance; it would later make applets obsolete. Poor Smalltalk cratered almost overnight as corporate users flocked to Java (also because it was free - more on that later). By the early 2000s, Java was dominating programming and still is, even if the hype is all gone.</p>
<p>More recently, we&#39;ve witnessed a different kind of hype cycle with Rust. After spending a few wise years in beta where it could refine the design, Rust has been propelled by an enthusiastic online community (sometimes amusingly referred to as the Rust Evangelism Strike Force) which ceaselessly extolled its virtues of safety and speed in arguing to &quot;rewrite it in rust&quot;. Though I think Rust is a good language that deserves to succeed, it wouldn&#39;t have what measured success it has attained without the help of these dynamics (case in point: a great deal of available Rust jobs are in the similarly hypey crypto space).</p>
<h3>Killer framework</h3>
<p>Ruby, Elixir
Ruby on Rails is the epitome of the killer framework. Before Rails, Ruby was a fringe dynamic language outside of Japan. Its small community <a href="https://web.archive.org/web/20040904090155/http://poignantguide.net/ruby/">revelled</a> in the expressiveness and fun that Matz designed the language with. With Rails, it was easy to build database driven monolithic applications and quickly became the choice for a new breed of products, such as Twitter and Github. Developers learned Ruby just to use Rails, and the two became synonymous. Elixir is patterned after Ruby in more than just the syntax; Phoenix provides a similar killer framework as Rails in driving its adoption. </p>
<h3>Platform blessed</h3>
<p>Swift/Objective-C, JS
Kind of the opposite direction of the killer framework is when a language is propelled by </p>
<h3>Free and available</h3>
<p>C/C++, Java, everything</p>
<h3>Third-party ecosystem</h3>
<p>Python</p>
<h3>Corporate backing</h3>
<p>Java, Go</p>
<h3>IDE friendly</h3>
<p>C#, Java, Typescript</p>

  </body>
</html>
